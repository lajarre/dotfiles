#!/usr/bin/env bash
#
# git-substat - Show detailed status of all git submodules
#
# Displays branch, changes, and file counts for each submodule

set -euo pipefail

usage() {
  cat << 'EOF'
git substat - Show detailed status of all git submodules.

USAGE:
    git substat
    git substat --help | -h

DESCRIPTION:
    Shows status for each submodule: branch, changes, file counts.

    Legend: ðŸ‘” clean | ðŸ§º dirty | ðŸŒ¿ branch | ðŸ”€ branchâ‰ parent | ðŸŽ¯ detached@origin | â“ detached

EXAMPLES:
    ðŸ‘” ðŸŒ¿ lib-a     [main       ]
    ðŸ§º ðŸŒ¿ lib-b     [feature-x  ] ?1 M2 D1
    ðŸ‘” ðŸŽ¯ lib-c     [origin/main]
    ðŸ§º â“ lib-d     [abc1234    ] M3
    ðŸ‘” ðŸ”€ lib-e     [feature-y  ]

    Counts: ?=untracked M=modified D=deleted
EOF
}

if [[ "${1:-}" == "-h" || "${1:-}" == "--help" || "${1:-}" == "--usage" ]]; then
  usage
  exit 0
fi

if ! git rev-parse --git-dir >/dev/null 2>&1; then
  echo "Error: not in a git repository" >&2
  exit 1
fi

# Check if repository has submodules
if [[ ! -f .gitmodules ]]; then
  echo "No submodules found in this repository"
  exit 0
fi

# Collect submodule info
parent_branch=$(git branch --show-current 2>/dev/null || true)
declare -a lines=()
maxname=0
maxbranch=0

while IFS= read -r subpath; do
  [[ -z "$subpath" ]] && continue
  name=$(basename "$subpath")

  branch=$(git -C "$subpath" branch --show-current 2>/dev/null)
  if [ -z "$branch" ]; then
    # Detached HEAD - check if at origin/main or origin/master
    head_sha=$(git -C "$subpath" rev-parse HEAD 2>/dev/null)
    origin_main_sha=$(git -C "$subpath" rev-parse origin/main 2>/dev/null || true)
    origin_master_sha=$(git -C "$subpath" rev-parse origin/master 2>/dev/null || true)

    if [ -n "$origin_main_sha" ] && [ "$head_sha" = "$origin_main_sha" ]; then
      branchemoji="ðŸŽ¯"
      branchname="origin/main"
    elif [ -n "$origin_master_sha" ] && [ "$head_sha" = "$origin_master_sha" ]; then
      branchemoji="ðŸŽ¯"
      branchname="origin/master"
    else
      branchemoji="â“"
      # Show abbreviated commit hash
      branchname=$(git -C "$subpath" rev-parse --short HEAD 2>/dev/null || echo "???")
    fi
  else
    branchemoji="ðŸŒ¿"
    branchname="$branch"
    if [ -n "$parent_branch" ] && [ "$branch" != "$parent_branch" ] && [ "$branch" != "main" ] && [ "$branch" != "master" ]; then
      branchemoji="ðŸ”€"
    fi
  fi

  changes=$(git -C "$subpath" status -s 2>/dev/null)

  if [ -z "$changes" ]; then
    status="ðŸ‘”"
    counts=""
  else
    status="ðŸ§º"
    u=$(echo "$changes" | grep -c "^??" || true)
    m=$(echo "$changes" | grep -c "^ M" || true)
    d=$(echo "$changes" | grep -c "^ D" || true)
    counts=""
    [ "$u" -gt 0 ] && counts="?$u "
    [ "$m" -gt 0 ] && counts="${counts}M$m "
    [ "$d" -gt 0 ] && counts="${counts}D$d"
  fi

  lines+=("$status|$branchemoji|$name|$branchname|$counts")
  (( ${#name} > maxname )) && maxname=${#name}
  (( ${#branchname} > maxbranch )) && maxbranch=${#branchname}
done < <(git config --file .gitmodules --get-regexp path | awk '{print $2}')

# Print table
for line in "${lines[@]}"; do
  IFS='|' read -r status branchemoji name branchname counts <<< "$line"
  if [ -n "$branchname" ]; then
    printf "%s %s %-${maxname}s [%-${maxbranch}s] %s\n" "$status" "$branchemoji" "$name" "$branchname" "$counts"
  else
    printf "%s %s %-${maxname}s  %-${maxbranch}s  %s\n" "$status" "$branchemoji" "$name" "" "$counts"
  fi
done
